/* ###
 * IP: AgentDecompile
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
// Builds a Ghidra Extension for a given Ghidra installation.
//
// An absolute path to the Ghidra installation directory must be supplied either by setting the
// GHIDRA_INSTALL_DIR environment variable or Gradle project property:
//
//     > export GHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//     > gradle
//
//         or
//
//     > gradle -PGHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//
// Gradle should be invoked from the directory of the project to build.  Please see the
// application.gradle.version property in <GHIDRA_INSTALL_DIR>/Ghidra/application.properties
// for the correction version of Gradle to use for the Ghidra installation you specify.

//----------------------START "DO NOT MODIFY" SECTION------------------------------
def ghidraInstallDir

if (System.env.GHIDRA_INSTALL_DIR) {
	ghidraInstallDir = System.env.GHIDRA_INSTALL_DIR
}
else if (project.hasProperty("GHIDRA_INSTALL_DIR")) {
	ghidraInstallDir = project.getProperty("GHIDRA_INSTALL_DIR")
}
else {
	throw new GradleException("GHIDRA_INSTALL_DIR is not set. Please set it as an environment variable or Gradle project property.")
}

task distributeExtension {
	group "Ghidra"

	apply from: new File(ghidraInstallDir).getCanonicalPath() + "/support/buildExtension.gradle"
	dependsOn ':buildExtension'
}
//----------------------END "DO NOT MODIFY" SECTION-------------------------------

task install(type: Exec) {
    dependsOn buildExtension

    group = "Installation"
    description = "Installs the zip package in installed Ghidra's default extension directory"

    workingDir ghidraInstallDir + '/Ghidra/Extensions'
    commandLine 'unzip', '-o', "${buildExtension.destinationDirectory.getAsFile().get().getAbsolutePath()}/${buildExtension.archiveBaseName.get()}.${buildExtension.archiveExtension.get()}"

    doLast {
        logger.quiet("Installed AgentDecompile")
    }
}

sourceSets {
	integrationTest {
		java {
			srcDirs = ['src/test.slow/java']
		}
		resources {
			srcDirs = ['src/test.slow/resources']
		}
		compileClasspath += main.output + test.output
		runtimeClasspath += test.output + jar.outputs.files
	}
}

configurations {
	integrationTestImplementation.extendsFrom testImplementation

	// Force Jackson 2.20.x to be compatible with MCP SDK v0.17.0
	all {
		resolutionStrategy {
			force 'com.fasterxml.jackson.core:jackson-core:2.20.1'
			force 'com.fasterxml.jackson.core:jackson-databind:2.20.1'
			force 'com.fasterxml.jackson.core:jackson-annotations:2.20'  // 2.20 dropped patch versions
			force 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.20.1'
		}
	}
}

repositories {
	// Declare dependency repositories here.  This is not needed if dependencies are manually
	// dropped into the lib/ directory.
	// See https://docs.gradle.org/current/userguide/declaring_repositories.html for more info.
	// Ex: mavenCentral()
	mavenCentral()
	maven { url 'https://repo.spring.io/milestone' }
	maven { url 'https://repo.spring.io/snapshot' }
	maven {
		name = 'Central Portal Snapshots'
		url = 'https://central.sonatype.com/repository/maven-snapshots/'
	}
}

dependencies {
	// Any external dependencies added here will automatically be copied to the lib/ directory when
	// this extension is built.
	implementation platform("io.modelcontextprotocol.sdk:mcp-bom:1.0.0")
	implementation "io.modelcontextprotocol.sdk:mcp"
	implementation "io.modelcontextprotocol.sdk:mcp-json-jackson2"
	implementation "jakarta.servlet:jakarta.servlet-api:6.1.0"
	// Add Jetty for embedded servlet support
	implementation "org.eclipse.jetty:jetty-server:11.0.26"
	implementation "org.eclipse.jetty:jetty-servlet:11.0.26"

	// Force Jackson 2.20.x to be compatible with MCP SDK v0.17.0
	implementation "com.fasterxml.jackson.core:jackson-core:2.20.1"
	implementation "com.fasterxml.jackson.core:jackson-databind:2.20.1"
	implementation "com.fasterxml.jackson.core:jackson-annotations:2.20"  // 2.20 dropped patch versions

	// Testing dependencies
	testImplementation "org.mockito:mockito-core:5.21.0"
	testImplementation "org.mockito:mockito-inline:5.2.0"

	// Ghidra test dependencies
	testImplementation "org.hamcrest:hamcrest:3.0"
	testImplementation "junit:junit:4.13.2"

	// Integration test dependencies inherit from testImplementation via configurations block

	// PCode test dependencies (uncomment if you have PCode tests)
	// pcodeTestImplementation "junit:junit:4.13.2"
}

task integrationTest(type: Test) {
	group 'verification'
	description 'Runs integration tests (tests that require GUI/headed environment)'
	testClassesDirs = sourceSets.integrationTest.output.classesDirs
	classpath = sourceSets.integrationTest.runtimeClasspath

	// Fork every test to prevent configuration conflicts
	forkEvery 1

	// These tests require a GUI environment
	systemProperty 'java.awt.headless', 'false'

	// Exclude suite classes
	exclude '**/*Suite*'

	// Clean test results before running to avoid file locking issues on Windows
	// This handles cases where files from previous test runs are still locked
	doFirst {
		def testResultsDir = project.file("${project.buildDir}/test-results/integrationTest")
		if (testResultsDir.exists()) {
			// On Windows, file handles may remain open briefly after program.release()
			// Try multiple times with delays to allow handles to close
			def maxRetries = 5
			def retryDelay = 500
			def deleted = false
			def lastException = null

			for (int i = 0; i < maxRetries && !deleted; i++) {
				try {
					if (i > 0) {
						Thread.sleep(retryDelay * i)
					}
					// Try to delete just the binary subdirectory if it exists
					def binaryDir = new File(testResultsDir, "binary")
					if (binaryDir.exists()) {
						try {
							binaryDir.deleteDir()
						} catch (Exception e) {
							// If binary dir can't be deleted, try to delete individual files
							binaryDir.listFiles()?.each { file ->
								try {
									file.delete()
								} catch (Exception ignored) {
									// Ignore individual file deletion failures
								}
							}
						}
					}
					// Try to delete the whole directory
					testResultsDir.deleteDir()
					deleted = true
				} catch (Exception e) {
					lastException = e
					if (i < maxRetries - 1) {
						logger.debug("Retry ${i + 1}/${maxRetries - 1}: Could not delete test results directory, will retry...")
					}
				}
			}

			if (!deleted) {
				// If still locked after retries, log warning but continue
				// Gradle will handle the conflict or use a different location
				logger.warn("Could not delete test results directory after ${maxRetries} attempts: ${lastException?.message ?: 'unknown error'}. Tests will continue.")
			}
		}
	}
}

// Make check depend on integrationTest
check.dependsOn integrationTest

// Exclude additional files from the built extension
afterEvaluate {
	if (tasks.findByName('buildExtension')) {
		tasks.buildExtension {
			// Build artifacts
			exclude '.gradle/**'
			exclude 'build/**'
			exclude 'dist/**'
			exclude 'bin/**'

			// IDE and editor files
			exclude '.idea/**'
			exclude '.vscode/**'
			exclude '.cursor/**'
			exclude '.vim/**'
			exclude '.history/**'
			exclude '**/.idea/**'
			exclude '**/.vscode/**'
			exclude '**/.cursor/**'
			exclude '**/.vim/**'
			exclude '**/.history/**'

			// Version control
			exclude '.git/**'
			exclude '.svn/**'
			exclude '.hg/**'
			exclude '**/.git/**'
			exclude '**/.svn/**'
			exclude '**/.hg/**'

			// Python virtual environments and artifacts
			exclude '.venv/**'
			exclude 'venv/**'
			exclude 'env/**'
			exclude '__pycache__/**'
			exclude '**/.venv/**'
			exclude '**/venv/**'
			exclude '**/env/**'
			exclude '**/__pycache__/**'
			exclude '**/*.pyc'
			exclude '**/*.pyo'
			exclude '**/*.pyd'
			exclude '**/*.egg-info/**'
			exclude '.mypy_cache/**'
			exclude '**/.mypy_cache/**'

			// OS files
			exclude '.DS_Store'
			exclude 'Thumbs.db'
			exclude 'desktop.ini'
			exclude '**/.DS_Store'
			exclude '**/Thumbs.db'
			exclude '**/desktop.ini'

			// Development and testing files
			exclude '.env'
			exclude '.agentdecompile/**'
			exclude '**/.env'
			exclude '**/.agentdecompile/**'
			exclude '**/*.hprof'
			exclude '**/*.log'
			exclude '**/*.tmp'
			exclude '**/*.temp'
			exclude '.coverage'
			exclude 'htmlcov/**'
			exclude '.pytest_cache/**'
			exclude '**/.coverage'
			exclude '**/htmlcov/**'
			exclude '**/.pytest_cache/**'

			// Slim extension: exclude repo/CI/docs/tests (keep only README, LICENSE, extension essentials)
			exclude '.github/**'
			exclude 'docs/**'
			exclude 'tests/**'
			exclude 'vendor/**'
			exclude 'src/**'

			// Gradle wrapper (project uses system gradle; per .gitignore)
			exclude 'gradlew'
			exclude 'gradlew.bat'
			exclude 'gradle/wrapper/**'
			exclude '.gradletasknamecache'
			exclude 'gradle-app.setting'

			// Root files not required by the extension at runtime (aligned with .gitignore)
			exclude '.cursorrules'
			exclude '.dockerignore'
			exclude '.env.example'
			exclude '.gitignore'
			exclude '.gitattributes'
			exclude '.markdownlint.json'
			exclude 'AGENTS.md'
			exclude 'build-and-install.ps1'
			exclude 'build.gradle'
			exclude 'CLAUDE.md'
			exclude 'CONTRIBUTING.md'
			exclude 'debug_apikey.java'
			exclude 'debug_test.java'
			exclude 'docker-compose.yml'
			exclude 'Dockerfile'
			exclude 'docker/**'
			exclude 'gradle.properties'
			exclude 'pyproject.toml'
			exclude 'run-all-tests.ps1'
			exclude 'TOOLS_LIST.md'
			exclude 'uv.lock'
		}
	}
}
